import { Order, InsertOrder, Position, InsertPosition } from "@shared/schema";
import { storage } from "../storage";

interface BrokerAdapter {
  submitOrder(order: Order): Promise<string>; // Returns broker order ID
  cancelOrder(brokerOrderId: string): Promise<void>;
  getOrderStatus(brokerOrderId: string): Promise<string>;
}

// Paper trading broker adapter
class PaperBrokerAdapter implements BrokerAdapter {
  async submitOrder(order: Order): Promise<string> {
    // Simulate order processing delay
    await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));

    // Generate mock broker order ID
    const brokerOrderId = `PAPER_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Simulate fill (simplified)
    const fillPrice = await this.simulateFill(order);

    // Update order as filled
    await storage.updateOrder(order.id, {
      status: "FILLED",
      brokerOrderId,
      filledQuantity: order.quantity,
      avgFillPrice: fillPrice.toString(),
      // filledAt: new Date(), // Auto-generated by database
      commission: this.calculateCommission(order, fillPrice),
      slippage: this.calculateSlippage(order, fillPrice),
    });

    // Create or update position
    await this.updatePosition(order, fillPrice);

    return brokerOrderId;
  }

  async cancelOrder(brokerOrderId: string): Promise<void> {
    console.log(`Cancelling order: ${brokerOrderId}`);
  }

  async getOrderStatus(brokerOrderId: string): Promise<string> {
    return "FILLED"; // Simplified for paper trading
  }

  private async simulateFill(order: Order): Promise<number> {
    const currentPrice = { price: 1.0500 + Math.random() * 0.01 }; // Mock price data
    if (!currentPrice) {
      throw new Error(`No price data available for ${order.symbol}`);
    }

    // Simulate slippage
    const slippageFactor = (Math.random() - 0.5) * 0.0002; // Â±0.02% slippage
    const side = order.side === "BUY" ? 1 : -1;

    return currentPrice.price * (1 + (slippageFactor * side));
  }

  private calculateCommission(order: Order, fillPrice: number): string {
    // Simplified commission calculation
    const volume = parseFloat(order.quantity) * fillPrice;
    const commission = volume * 0.00002; // 0.002% commission
    return commission.toFixed(2);
  }

  private calculateSlippage(order: Order, fillPrice: number): string {
    // This would be actual price - expected price
    const expectedPrice = order.price ? parseFloat(order.price) : fillPrice;
    const slippage = Math.abs(fillPrice - expectedPrice);
    return slippage.toFixed(5);
  }

  private async updatePosition(order: Order, fillPrice: number): Promise<void> {
    try {
      // Check if position already exists for this symbol
      const openPositions = await storage.getOpenPositions(order.accountId);
      const existingPosition = openPositions.find(p => p.symbol === order.symbol);

      if (existingPosition) {
        // Update existing position
        const currentQty = parseFloat(existingPosition.quantity);
        const orderQty = parseFloat(order.quantity);
        const newQty = order.side === "BUY" ? currentQty + orderQty : currentQty - orderQty;

        if (Math.abs(newQty) < 0.001) {
          // Position closed - calculate realized P&L
          const realizedPnL = this.calculateRealizedPnL(existingPosition, fillPrice, orderQty);

          await storage.updatePosition(existingPosition.id, {
            quantity: "0",
            isOpen: false,
            realizedPnL: realizedPnL.toString(),
          });

          // Create position close alert
          await storage.createAlert({
            level: "INFO",
            title: "Position Closed",
            message: `${order.symbol} position closed with P&L: $${realizedPnL.toFixed(2)}`,
            source: "ORDER_MANAGER",
          });
        } else {
          // Position size changed
          const currentAvgPrice = parseFloat(existingPosition.avgPrice);
          const newAvgPrice = ((currentAvgPrice * Math.abs(currentQty)) + (fillPrice * orderQty)) / Math.abs(newQty);

          // Calculate unrealized P&L
          const unrealizedPnL = this.calculateUnrealizedPnL(newQty, newAvgPrice, fillPrice);

          await storage.updatePosition(existingPosition.id, {
            quantity: Math.abs(newQty).toString(),
            side: newQty > 0 ? "BUY" : "SELL",
            avgPrice: newAvgPrice.toString(),
            currentPrice: fillPrice.toString(),
            unrealizedPnL: unrealizedPnL.toString(),
          });
        }
      } else {
        // Create new position
        const newPosition: InsertPosition = {
          accountId: order.accountId,
          strategyId: order.strategyId,
          symbol: order.symbol,
          side: order.side,
          quantity: order.quantity,
          avgPrice: fillPrice.toString(),
          currentPrice: fillPrice.toString(),
          stopLoss: order.stopLoss,
          takeProfit: order.takeProfit,
          unrealizedPnL: "0",
          realizedPnL: "0",
        };

        const position = await storage.createPosition(newPosition);

        // Create position open alert
        await storage.createAlert({
          level: "INFO",
          title: "Position Opened",
          message: `${order.symbol} ${order.side} position opened: ${order.quantity} lots at ${fillPrice}`,
          source: "ORDER_MANAGER",
        });
      }
    } catch (error) {
      console.error("Position update error:", error);

      // Create error alert
      await storage.createAlert({
        level: "CRITICAL",
        title: "Position Update Failed",
        message: `Failed to update position for order ${order.id}: ${error.message}`,
        source: "ORDER_MANAGER",
      });
    }
  }

  private calculateRealizedPnL(position: any, fillPrice: number, quantity: number): number {
    const avgPrice = parseFloat(position.avgPrice);
    const side = position.side;

    if (side === "BUY") {
      return (fillPrice - avgPrice) * quantity * 100000; // Convert to USD for standard lot
    } else {
      return (avgPrice - fillPrice) * quantity * 100000;
    }
  }

  private calculateUnrealizedPnL(quantity: number, avgPrice: number, currentPrice: number): number {
    const pnlPerUnit = Math.abs(quantity) > 0 ?
      (quantity > 0 ? currentPrice - avgPrice : avgPrice - currentPrice) : 0;
    return pnlPerUnit * Math.abs(quantity) * 100000; // Convert to USD
  }
}

class OrderManager {
  private brokerAdapters = new Map<string, BrokerAdapter>();
  private pendingOrders = new Set<string>();

  constructor() {
    // Initialize paper broker adapter
    this.brokerAdapters.set("paper", new PaperBrokerAdapter());
  }

  async submitOrder(orderData: InsertOrder): Promise<Order> {
    try {
      // Create order in database
      const order = await storage.createOrder(orderData);
      this.pendingOrders.add(order.id);

      // Get appropriate broker adapter
      const brokerAdapter = this.brokerAdapters.get("paper"); // Simplified
      if (!brokerAdapter) {
        throw new Error("No broker adapter available");
      }

      // Submit to broker
      const brokerOrderId = await brokerAdapter.submitOrder(order);

      this.pendingOrders.delete(order.id);

      console.log(`Order submitted successfully: ${order.id} -> ${brokerOrderId}`);
      return order;
    } catch (error) {
      console.error("Order submission error:", error);
      throw error;
    }
  }

  async createCloseOrder(position: Position): Promise<Order> {
    const closeQuantity = parseFloat(position.quantity);
    const closeSide = position.side === "BUY" ? "SELL" : "BUY";

    const closeOrder: InsertOrder = {
      accountId: position.accountId,
      strategyId: position.strategyId,
      symbol: position.symbol,
      side: closeSide,
      quantity: closeQuantity.toString(),
      type: "MARKET",
      status: "PENDING",
      idempotencyKey: `CLOSE_${position.id}_${Date.now()}`,
    };

    return await this.submitOrder(closeOrder);
  }

  // Health check methods
  async executeOrder(order: any): Promise<any> {
    console.log(`Executing order: ${order.id}`);
    // Placeholder for order execution logic
    return { ...order, status: "FILLED", executedAt: new Date().toISOString() };
  }

  isHealthy(): boolean {
    return true; // Mock health status
  }

  async getLatency(): Promise<number> {
    return Math.floor(Math.random() * 30) + 10; // Mock latency between 10-40ms
  }

  async getPendingOrderCount(): Promise<number> {
    return 0; // Mock pending orders count
  }
}

export const orderManager = new OrderManager();