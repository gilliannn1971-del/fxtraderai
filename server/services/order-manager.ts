import { Order, InsertOrder, Position, InsertPosition } from "@shared/schema";
import { storage } from "../storage";

interface BrokerAdapter {
  submitOrder(order: Order): Promise<string>; // Returns broker order ID
  cancelOrder(brokerOrderId: string): Promise<void>;
  getOrderStatus(brokerOrderId: string): Promise<string>;
}

// Paper trading broker adapter
class PaperBrokerAdapter implements BrokerAdapter {
  async submitOrder(order: Order): Promise<string> {
    // Simulate order processing delay
    await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));
    
    // Generate mock broker order ID
    const brokerOrderId = `PAPER_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Simulate fill (simplified)
    const fillPrice = await this.simulateFill(order);
    
    // Update order as filled
    await storage.updateOrder(order.id, {
      status: "FILLED",
      brokerOrderId,
      filledQuantity: order.quantity,
      avgFillPrice: fillPrice.toString(),
      // filledAt: new Date(), // Auto-generated by database
      commission: this.calculateCommission(order, fillPrice),
      slippage: this.calculateSlippage(order, fillPrice),
    });

    // Create or update position
    await this.updatePosition(order, fillPrice);
    
    return brokerOrderId;
  }

  async cancelOrder(brokerOrderId: string): Promise<void> {
    console.log(`Cancelling order: ${brokerOrderId}`);
  }

  async getOrderStatus(brokerOrderId: string): Promise<string> {
    return "FILLED"; // Simplified for paper trading
  }

  private async simulateFill(order: Order): Promise<number> {
    const currentPrice = { price: 1.0500 + Math.random() * 0.01 }; // Mock price data
    if (!currentPrice) {
      throw new Error(`No price data available for ${order.symbol}`);
    }

    // Simulate slippage
    const slippageFactor = (Math.random() - 0.5) * 0.0002; // Â±0.02% slippage
    const side = order.side === "BUY" ? 1 : -1;
    
    return currentPrice.price * (1 + (slippageFactor * side));
  }

  private calculateCommission(order: Order, fillPrice: number): string {
    // Simplified commission calculation
    const volume = parseFloat(order.quantity) * fillPrice;
    const commission = volume * 0.00002; // 0.002% commission
    return commission.toFixed(2);
  }

  private calculateSlippage(order: Order, fillPrice: number): string {
    // This would be actual price - expected price
    const expectedPrice = order.price ? parseFloat(order.price) : fillPrice;
    const slippage = Math.abs(fillPrice - expectedPrice);
    return slippage.toFixed(5);
  }

  private async updatePosition(order: Order, fillPrice: number): Promise<void> {
    try {
      // Check if position already exists for this symbol
      const openPositions = await storage.getOpenPositions(order.accountId);
      const existingPosition = openPositions.find(p => p.symbol === order.symbol);

      if (existingPosition) {
        // Update existing position
        const currentQty = parseFloat(existingPosition.quantity);
        const orderQty = parseFloat(order.quantity);
        const newQty = order.side === "BUY" ? currentQty + orderQty : currentQty - orderQty;

        if (newQty === 0) {
          // Position closed
          await storage.updatePosition(existingPosition.id, {
            quantity: "0",
            isOpen: false,
            // closedAt: new Date(), // Auto-generated by database
          });
        } else {
          // Position size changed
          const currentAvgPrice = parseFloat(existingPosition.avgPrice);
          const newAvgPrice = ((currentAvgPrice * Math.abs(currentQty)) + (fillPrice * orderQty)) / Math.abs(newQty);
          
          await storage.updatePosition(existingPosition.id, {
            quantity: Math.abs(newQty).toString(),
            side: newQty > 0 ? "BUY" : "SELL",
            avgPrice: newAvgPrice.toString(),
            currentPrice: fillPrice.toString(),
          });
        }
      } else {
        // Create new position
        const newPosition: InsertPosition = {
          accountId: order.accountId,
          strategyId: order.strategyId,
          symbol: order.symbol,
          side: order.side,
          quantity: order.quantity,
          avgPrice: fillPrice.toString(),
          currentPrice: fillPrice.toString(),
          stopLoss: order.stopLoss,
          takeProfit: order.takeProfit,
          unrealizedPnL: "0",
          realizedPnL: "0",
        };

        await storage.createPosition(newPosition);
      }
    } catch (error) {
      console.error("Position update error:", error);
    }
  }
}

class OrderManager {
  private brokerAdapters = new Map<string, BrokerAdapter>();
  private pendingOrders = new Set<string>();

  constructor() {
    // Initialize paper broker adapter
    this.brokerAdapters.set("paper", new PaperBrokerAdapter());
  }

  async submitOrder(orderData: InsertOrder): Promise<Order> {
    try {
      // Create order in database
      const order = await storage.createOrder(orderData);
      this.pendingOrders.add(order.id);

      // Get appropriate broker adapter
      const brokerAdapter = this.brokerAdapters.get("paper"); // Simplified
      if (!brokerAdapter) {
        throw new Error("No broker adapter available");
      }

      // Submit to broker
      const brokerOrderId = await brokerAdapter.submitOrder(order);
      
      this.pendingOrders.delete(order.id);
      
      console.log(`Order submitted successfully: ${order.id} -> ${brokerOrderId}`);
      return order;
    } catch (error) {
      console.error("Order submission error:", error);
      throw error;
    }
  }

  async createCloseOrder(position: Position): Promise<Order> {
    const closeQuantity = parseFloat(position.quantity);
    const closeSide = position.side === "BUY" ? "SELL" : "BUY";

    const closeOrder: InsertOrder = {
      accountId: position.accountId,
      strategyId: position.strategyId,
      symbol: position.symbol,
      side: closeSide,
      quantity: closeQuantity.toString(),
      type: "MARKET",
      status: "PENDING",
      idempotencyKey: `CLOSE_${position.id}_${Date.now()}`,
    };

    return await this.submitOrder(closeOrder);
  }

  // Health check methods
  isHealthy(): boolean {
    return true; // Simplified health check
  }

  async getLatency(): Promise<number> {
    return Math.floor(Math.random() * 40) + 15; // Mock latency 15-55ms
  }

  async getPendingOrderCount(): Promise<number> {
    return this.pendingOrders.size;
  }
}

export const orderManager = new OrderManager();
